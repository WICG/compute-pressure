
<!DOCTYPE html>
<meta charset="utf-8" />
<title>Compute Pressure API</title>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script class="remove">
  // All config options at https://respec.org/docs/
  const respecConfig = {
    shortName: "compute-pressure",
    group: "wicg",
    specStatus: "CG-DRAFT",
    xref: "web-platform",
    formerEditors: [
      {
        name: "Olivier Yiptong",
        company: "Google Inc.",
        companyURL: "https://google.com",
      }
    ],
    editors: [
      {
        name: "Kenneth Rohde Christiansen",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 57705,
      },
      {
        name: "Arnaud Mandy",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 126342,
      },
      {
        name: "Victor Costan",
        company: "Google Inc.",
        companyURL: "https://google.com",
      }
    ],
    testSuiteURI: "https://github.com/web-platform-tests/wpt/labels/compute-pressure",
  };
</script>
<section id="abstract">
  <p>
    The <cite>Compute Pressure API</cite> provides a way for websites to react to changes
    in the CPU consumption of the target device, such that websites can trade off
    resources for an improved user experience.
  </p>
</section>
<section id="sotd"></section>
<section class="informative">
  <h2>Introduction</h2>
  <p>
    Modern applications often need to balance the trade offs and advantages of fully utilizing
    the system's computing resources, in order to provide a modern and delightful user experience.
  </p>
  <p>
    As an example, many applications can render video effects with varying degrees of sophistication.
    These applications aim to provide the best user experience, while avoiding driving the user's
    device into a high pressure regime.
  </p>
  <p>
    Utilization of [=processing units=] close to and often reaching 100% can lead to a bad
    user experience, as different tasks are fighting for the processing time.
    This can lead to slowless, which is especially noticeable with input delay.

    Further, a prolonged utilization close 100% can cause the [=processing units=] to heat up due to prolonged
    boosting, which can lead to throttling, resulting in an even worse user experience.
  </p>
  <p>
    As a result of thermal limits, many smartphones, tablets and laptops can become uncomfortably hot
    to the touch. The fans in laptops and desktops can become so loud that they disrupt conversations
    or the usersâ€™ ability to focus.
  </p>
  <p>
    In many cases, a device under high pressure appears to be unresponsive, as the operating
    system may fail to schedule the threads advancing the task that the user is waiting for. See also
    <a href="https://github.com/oyiptong/compute-pressure/#goals--motivating-use-cases">Compute Pressure:
    Use Cases</a>.
  </p>
</section>
<section>
  <h2>A Note on Feature Detection</h2>
  <p><i>This section is non-normative.</i></p>
  <p>
    Feature detection is an established web development best practice. Resources on the topic are plentiful on- and
    offline and the purpose of this section is not to discuss it further, but rather to put it in the context of
    detecting hardware-dependent features.
  </p>
  <p>
    Consider the below feature detection examples:
  </p>
  <aside class="example" title="Checking existence of ComputePressureObserver interface">
    <p>
      This simple example illustrates how to check whether the User Agent exposes the
      ComputePressureObserver interface
    </p>
    <pre class="js">
      if ("ComputePressureObserver" in globalThis) {
        // use ComputePressureObserver interface
      }
    </pre>
  </aside>
  <p>
    Checking against 'globalThis' will work everywhere JavaScript is available, even in a worker
    and if the above is `true`, then the API is present.

    The check, however, does not tell whether that API is actually connected to a
    real [=platform collector=], whether the [=platform collector=] is collecting real telemetry
    readings, or whether the user is going to allow you to access it.
  </p>
</section>
<section>
  <h2>Concepts</h2>
  <p>
    This specification defines the following concepts:
  </p>
  <section>
    <h3><dfn>Processing Units</dfn></h3>
    <p>
      Computing devices consist of a multitude of different processing units such as the Central
      Processing Unit (CPU), the Graphics Processing Unit (GPU) and many specialized
      processing units. The latter are becoming popular such as ones designed to accelerate specific
      tasks like machine learning or computer vision.
    </p>
  </section>
  <section>
    <h3><dfn>Sampling Frequency</dfn> and <dfn>Reporting Frequency</dfn></h3>
    <p>
      The [=sampling frequency=] for a [=platform collector=] is defined as a frequency at which the user agent
      obtains telemetry readings from the underlying platform.
    </p>
    <p>
    The [=reporting frequency=] for a concrete {{ComputePressureObserver}} object is defined as a frequency
    at which {{ComputePressureUpdateCallback}} of this object will be invoked.
    </p>
    <p>
    A {{ComputePressureObserver}} object cannot access new readings at a higher rate than the user agent
      obtains them from the underlying platform, therefore the [=reporting frequency=] can never exceed the [=sampling frequency=].
    </p>
    <p>
      The [=reporting frequency=] can vary based on the difference in values between readings at [=sampling frequency=].
      If between two consecutive samplings the values of telemetry readings are falling into the same bucket, the values are considered
      to be unchanged and {{ComputePressureUpdateCallback}} of the object will not be invoked.
    </p>
  </section>
</section>

<section> <h2>Platform primitives</h2>
  <p>
    The term <dfn>platform collector</dfn> refers to platform interface, with which the [=user agent=] interacts to
    obtain the telemetry readings required by this specification.
  </p>
  <p>
    A [=platform collector=] can be defined by the underlying platform (e.g. in a native telemetry
    framework) or by the [=user agent=], if it has a direct access to hardware counters.
  </p>
  <p>
    From the implementation perspective [=platform collector=] can be treated as a software proxy for the
    corresponding hardware counters. It is possible to have multiple [=platform collector=] simultaneously
    interacting with the same underlying hardware if the underlying platform suppports it.
  </p>
  <p>
    In simple cases, a [=platform collector=] represents individual hardware counters, but if the provided
    counter readings are a product of data fusion performed in software, the [=platform collector=]
    represents the results of the data fusion process. This may happen in user space or in kernel space.
  </p>
  <p>
    As collecting telemetry data often means polling hardware counters, it is not a free operation and thus,
    it should not happen if there are no one observing the data. The term <dfn>active observers</dfn> refer
    to a [=user agent=] wide counter, representing how many instances of {{ComputePressureObserver}} that
    are active across the [=user agent=]. The [=active observers=] value is initially `0`.
  </p>
  <p>
    A [=platform collector=] samples data at a specific frequency. A [=user agent=] may modify this frequency
    (if possible) for privacy reasons, or ignore and fuse certain readings.
  </p>
  <p>
    When a sample is obtained from the [=platform collector=], the [=user agent=] MUST run the [[[#notify-observers]]]
    algorithm a per the [[[#processing-model]]]
  </p>
</section>

<section> <h2>Pressure States</h2>
  <p>
    <dfn>Pressure states</dfn> represents the minimal set of useful states that allows websites
    to react to changes in compute pressure with minimal degration in quality or service, or user
    experience.
  </p>
  <pre class="idl">
    enum PressureState { "nominal", "fair", "serious", "critical" };
  </pre>
  <p>
    The <dfn>PressureState</dfn> enum represents the [=pressure state=] with the following states:
  </p>
  <p>
    <style>
      @counter-style pressure-states-emoji {
        system: cyclic;
        symbols: "âšª" "ðŸŸ¢" "ðŸŸ¡" "ðŸ”´";
        suffix: " ";
      }
      .pressure-states {
        list-style-type: pressure-states-emoji;
      }
    </style>
    <ul class="pressure-states">
      <li>
        <b>Nominal</b>: Current workloads are causing minimal pressure, allowing the system to run
        at a lower clock frequency to preserve power.
      </li>
      <li>
        <b>Fair</b>: The system is doing fine, everything is smooth and it can take on additional work without issues.
      </li>
      <li>
        <b>Serious</b>: There is some serious pressure on the system, but it is sustainable and the system
        is doing well, but it is getting close to its limits:
        <ul>
          <li>
            Clock speed (depending on AC or DC power) is consistently high
          </li>
          <li>
            Thermals are high but system can handle it
          </li>
        </ul>
        At this point, if you add more work the system may move into critical.
      </li>
      <li>
        <b>Critical</b>: The system is now about to reach its limits, but it hasnâ€™t reached <em>the</em> limit yet.
        Critical doesnâ€™t mean that the system is being actively throttled, but this state is not sustainable for
        the long run and might result in throttling if the workload remains the same. This signal is the last call
        for the web application to lighten its workload.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Compute Pressure Observer</h2>
The Compute Pressure Observer API enables developers to understand the utilization characteristics of a CPU.

<section data-dfn-for="ComputePressureObserverCallback">
  <h3>The <a>ComputePressureUpdateCallback</a> callback</h3>
  <pre class="idl">
    callback ComputePressureUpdateCallback = undefined (
      sequence&lt;ComputePressureEntry&gt; entries,
      ComputePressureObserver observer
    );
  </pre>
  This callback will be invoked when the [=pressure state=] changes.
</section>

<section  data-dfn-for="ComputePressureObserver"> <h2>The <a>ComputePressureObserver</a> object</h2>
  <p>
    The {{ComputePressureObserver}} can be used to observe changes in the [=pressure states=].
  </p>
  <pre class="idl">
    enum ComputePressureTarget { "cpu" };

    [Exposed=Window]
    interface ComputePressureObserver {
      constructor(ComputePressureUpdateCallback callback);

      undefined observe(ComputePressureTarget target, optional ComputePressureObserverOptions options = {});
      undefined unobserve(ComputePressureTarget target);
      undefined disconnect();
      sequence&lt;ComputePressureEntry&gt; takeRecords();

      [SameObject] static readonly attribute FrozenArray&lt;DOMString&gt; supportedTargetTypes;
    };
  </pre>

  <p>The <dfn>ComputePressureObserver</dfn> interface represents a {{ComputePressureObserver}}.</p>

  <section  data-dfn-for="ComputePressureObserver">
    <h3>
      Internal slots
    </h3>
    <p data-dfn-for="Document">
      Each [=document=] has an <dfn>[[\ComputePressureObserverTaskQueued]]</dfn> flag which is initialized to `false`.
    </p>
    <p>
      A constructed  {{ComputePressureObserver}} object has the following internal slots.
    </p>
    <table class="simple">
      <thead>
        <tr>
          <th>
            Internal slot
          </th>
          <th>
            Initial value
          </th>
          <th>
            Description
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <dfn>[[\Callback]]</dfn>
          </td>
          <td>
            {{undefined}}
          </td>
          <td>
            An optional function of type {{ComputePressureUpdateCallback}}.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\Activated]]</dfn>
          </td>
          <td>
            `false`
          </td>
          <td>
            A {{boolean}} whether the observer is actively observing or not.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>[[\QueuedEntries]]</dfn>
          </td>
          <td>
            An empty [=queue=].
          </td>
          <td>
            A [=queue=] of zero or more {{ComputePressureEntry}} objects.
          </td>
        </tr>
      </tbody>
    </table>
  </section>
  <section>
    <h3>The <dfn>constructor()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/constructor()}} method, when invoked, MUST run the
      following step, given the arguments |callback:ComputePressureUpdateCallback|:
      <ol class="algorithm">
        <li>
          Let |this:ComputePressureObserver| be a new the {{ComputePressureObserver}} object.
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Callback]]}} to |callback|.
        </li>
        <li>
          Return |this|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>observe()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/observe()}} method, when invoked, MUST run the
      following step, given the arguments |target:ComputePressureTarget| and
      |options:ComputePressureObserverOptions|:
      <ol class="algorithm">
        <li>
          If |target| is not equal to {{ComputePressureTarget/cpu}}, abort these steps.
        </li>
        <li>
          If [=active observers=] is equal to `0`, activate the underlying [=platform collector=].
        </li>
        <li>
          Increment the [=active observers=] counter.
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Activated]]}} to `true`.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>unobserve()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/unobserve()}} method, when invoked, MUST run the
      following step, given the arguments |target:ComputePressureTarget|:
      <ol class="algorithm">
        <li>
          If |target| is not equal to {{ComputePressureTarget/cpu}}, abort these steps.
        </li>
        <li>
          Decrement the [=active observers=] counter.
        </li>
        <li>
          If [=active observers=] is equal to `0`, deactivate the underlying [=platform collector=].
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Activated]]}} to `false`.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>disconnect()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/disconnect()}} method, when invoked, MUST run the
      following step:
      <ol class="algorithm">
        <li>
          If |this|.{{ComputePressureObserver/[[Activated]]}} is `true`,
          decrement the [=active observers=] counter.
        </li>
        <li>
          If [=active observers=] is equal to `0`, deactivate the underlying [=platform collector=].
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Activated]]}} to `false`.
        </li>
        <li>
          [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>takeRecords()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/takeRecords()}} method, when invoked, MUST run the
      following step:
      <ol class="algorithm">

        <li>
          Let |entries| be a [=list/clone=] of |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
        </li>
        <li>
          [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
        </li>
        <li>
          Return |entries|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>supportedTargetTypes</dfn> attribute</h3>
    <p>
      The {{ComputePressureObserver/supportedTargetTypes}} attribute is informing on the supported target by the [=platform collector=].
      When {{ComputePressureObserver/supportedTargetTypes}}'s attribute getter is called, MUST run the following steps:
      <ol class="algorithm">
        <li>
          Let |targets| be a [=list=] of |target:ComputePressureTarget|.
        </li>
        <li>
          Return |observer|'s frozen array of supported target types.
        </li>
      </ol>
    </p>
    <aside class="note">
      <p>
        This attribute allows web developers to easily know which target types are supported by the user agent.
      </p>
    </aside>
  </section>
</section>

<section data-dfn-for="ComputePressureEntry">
  <h3>The <dfn>ComputePressureEntry</dfn> dictionary</h3>
  <pre class="idl">
    dictionary ComputePressureEntry {
      PressureState state;
      ComputePressureObserverOptions options;
    };
  </pre>
  <section>
    <h3>The <dfn>state</dfn> attribute</h3>
    <p>
      The {{ComputePressureEntry/state}} attribute represents the current CPU [=pressure state=].
    </p>
  </section>
  <section>
    <h3>The <dfn>options</dfn> attribute</h3>
    <p>
      The {{ComputePressureEntry/options}} attribute represents the {{ComputePressureObserverOptions}}
      dictionary that {{ComputePressureObserver}} was constructed with.
    </p>
  </section>
</section>

<section data-dfn-for="ComputePressureObserverOptions">
  <h3>The <dfn>ComputePressureObserverOptions</dfn> dictionary</h3>
  <pre class="idl">
    dictionary ComputePressureObserverOptions {
      // For future-proofing - expect things to be added here later.
    };
  </pre>
</section>

<section id="processing-model">
  <h3>Processing Model</h3>
  <p>
    This section outlines the steps the user agent must take when implementing the Compute Pressure Observer API.
  </p>
  <section id="create-entry">
    <h3>Create and populate a ComputePressureEntry</h3>
    <ol class="algorithm">
      <li>
        Let |readings| be the latest reading of the [=platform collector=].
      </li>
      <li>
        Let |entry:ComputePressureEntry| be a new {{ComputePressureEntry}} instance.
      </li>
      <aside class="note">
        TODO: https://github.com/WICG/compute-pressure/issues/46
      </aside>
      <li>
        Let |entry|.|state:PressureState| be an [=implementation-defined=] state given
        the data available from the [=platform collector=].
      </li>
      <li>
        Return |entry|.
      </li>
    </ol>
  </section>
  <section>
    <h3>Queue a ComputePressureEntry</h3>
    <p>
      To queue a {{ComputePressureEntry}} for a {{ComputePressureObserver}}
      |observer:ComputePressureObserver|, given a [=document=] |document:Document|, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Let |entry| be the result of running [[[#create-entry]]].
      </li>
      <li>
        [=Append=] it to |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
      </li>
      <li>
        [=Queue a compute pressure observer task=] for |document|.
      </li>
    </ol>
  </section>
  <section>
    <h3>Queue a ComputePressureObserver Task</h3>
    <p>
      The <dfn>ComputePressureObserver task source</dfn> is a [=task source=] used for scheduling tasks to [[[#notify-observers]]].
    </p>
    <p>
      To <dfn>queue a compute pressure observer task</dfn> for a [=document=] |document:Document|, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        If |document|.{{Document/[[ComputePressureObserverTaskQueued]]}} is set to `true`, return.
      </li>
      <li>
        Set |document|.{{Document/[[ComputePressureObserverTaskQueued]]}} to `true`.
      </li>
      <li>
        [=Queue=] a task on the [=ComputePressureObserver task source=] associated with the |document|'s [=event loop=] to [[[#notify-observers]]].
      </li>
    </ol>
  </section>
  <section id="notify-observers">
    <h3>Notify Compute Pressure Observers</h3>
    <ol class="algorithm">
      <li>
        Let |document:Document| be the [=environment settings object/responsible document=] of the [=current settings object=].
      </li>
      <li>
        If |document| is not [=Document/fully active=], about these steps.
      </li>
      <li>
        [=list/For each=] {{ComputePressureObserver}} instance |observer:ComputePressureObserver|,
        <ol>
          <li>
            If |observer|.{{ComputePressureObserver/[[Activated]]}} is `false`, then [=iteration/continue=].
          </li>
          <li>
            If |observer|.{{ComputePressureObserver/[[QueuedEntries]]}} [=list/is empty=], then [=iteration/continue=].
          </li>
          <li>
            Let |entries| be a [=list/clone=] of |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
          </li>
          <li>
            [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedEntries]]}}.
          </li>
          <li>
            Invoke |observer|.{{ComputePressureObserver/[[Callback]]}} with |entries| and |observer|.
          </li>
        </ol>
      </li>
    </ol>
  </section>
</section>

<section>
  <h2>
    Security and privacy considerations
  </h2>
  <section>
    <h3>Minimizing information exposure</h3>
    <p>
      Exposing hardware related events related to low level details such as exact CPU
      utilization or clock speed
      <a href="https://w3ctag.github.io/design-principles/#device-ids">
      increases the risk of harming the user's privacy</a>.
    </p>
    <p>
      To minimize this risk, only the absolute minimal
      amount of information needed to to support the use-cases is exposed.
    </p>
    <p>
      The subsections below describe the processing model. At a high level, the
      information exposed is reduced by the following steps:
      <ol>
        <li>
          <b>Rate-limiting</b> - The user agent notifies the application of changes in
          the information it can learn. Change notifications are rate-limited.
        </li>
      </ol>
      <section>
        <h4>Rate-limiting change notifications</h4>
        <p>
          We propose exposing the pressure state via
          rate-limited change notifications. This aims to remove the ability to observe
          the precise time when a value transitions between two states.
        </p>
        <p>
          More precisely, once the compute pressure observer is activated, it will be
          called once with initial values, and then be called when the values change.
          The subsequent calls will be rate-limited. When the callback is
          called, the most recent value is reported.
        </p>
        <p>
          The specification will recommend a rate limit of at most one call per second
          for the active window, and one call per 10 seconds for all other windows. We
          will also recommend that the call timings are jittered across origins.
        </p>
        <p>
          These measures benefit the user's privacy, by reducing the risk of
          identifying a device across multiple origins. The rate-limiting also benefits
          the user's security, by making it difficult to use this API for timing attacks.
          Last, rate-limiting change callbacks places an upper bound on the performance
          overhead of this API.
        </p>
        <p>
          Rate limiting can be implemented in the user agent, but it might also be
          possible to simply change the polling frequency of the underlying hardware
          counters, if not accessed via a higher level framework.
        </p>
      </section>
      <section>
        <h4>Third-party contexts</h4>
        <p>
          This API will only be available in frames served from the same origin as the
          top-level frame. This requirement is necessary for preserving the privacy
          benefits of the API's quantizing scheme.
        </p>
        <p>
          The same-origin requirement above implies that the API is only available in
          first-party contexts.
        </p>
      </section>
    </p>
  </section>
</section>
<section id="examples" class="informative">
  <h2>
    Examples
  </h2>
  <p>
    In this example we want to lower the number of concurrent video streams if pressure
    becomes critical. For the sake of simplicity we only consider this one state.
  </p>
  <p>
    As lowering the amount of streams might not result in exiting the critical state,
    or at least not immediately, we use a strategy where we lower one stream at the time
    every 30 seconds while still in the critical state.
  </p>
  <p>
    We accomplish this by making sure the callback is called at least once every 30 seconds,
    or when the state actually changes. When the state changes we reset the interval timer.
  </p>
  <pre class="example js" title="Adjusting the number of video feeds based on CPU usage">
    let timerId = -1;
    function pressureChange(entries) {
      // Clear timer every time we are called, either by an actual state change,
      // or when called by setTimeout (see below).
      if (timerId > 0) {
        clearTimeout(timerId);
      }

      // When entering critical state, we want to recheck every 30sec if we are
      // still in critical state and if so, further reduce our concurrent streams.
      // For this reason we create a timer for 30 seconds that will call us back
      // with the last result in there were no change.
      const lastEntryArray = [entries.at(entries.length - 1)];
      timerId = setTimeout(pressureChange.bind(this, lastentryArray), 30_000);

      for (const entry of entries) {
        if (entry.state == "critical") {
          let streamsCount = getStreamsCount();
          setStreamsCount(streamsCount--);
        }
      }
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{ComputePressureObserver/takeRecords()}},
    by retrieving the remaining |entries| accumulated since the last callback.
  </p>
  <p>
    It is recommended to do so before {{ComputePressureObserver/disconnect()}}, otherwise {{ComputePressureObserver/disconnect()}} will clear them and they will be lost.
  </p>
  <pre class="example js" title="Usage of takeRecords">
    function pressureChange(entries) {
      // do something with entries
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");

    // observe.disconnect() will be called promptly, no time to wait for
    // callback. latest entries are needed immediately or will be lost otherwise.
    const entries = takeRecords();

    // do something with entries.

    observer.disconnect();
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{ComputePressureObserver/unobserve()}}.
    {{ComputePressureObserver/unobserve()}} will stop observing the specified |target:ComputePressureTarget|.
    It will not clear the pending |entries| collected since the last callback.
  </p>
  <pre class="example js" title="Usage of unobserve">
    function pressureChange(entries) {
      // do something with entries
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");

    // some time later...

    observer.unobserve("cpu");

    // expected to have entries if callback pressureChange hasn't been called.
    const observerEntries = observer.takeRecord();
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{ComputePressureObserver/disconnect()}}.
    {{ComputePressureObserver/disconnect()}} will stop observing all |target:ComputePressureTarget| chosen 
    by previous {{ComputePressureObserver/observe()}} calls.
    At the same time it will also clear all pending |entries| collected since the last callback.
  </p>
  <pre class="example js" title="Usage of disconnect">
    function pressureClange(entries) {
      // do something with entries
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");

    // some time later...

    observer.disconnect();

    // list expected to be empty because of previous disconnect().
    const observerEntries = observer.takeRecord();
  </pre>
</section>
<section id="conformance">
  <p>
    This is required for specifications that contain normative material.
  </p>
</section>

<section class="appendix informative" id="acknowledgments"> <h2>Acknowledgments</h2>
  <p>
    Many thanks for valuable feedback and advice from
    Anssi Kostiainen,
    Arnaud Mandy,
    Asaf Yaffe,
    Chen Xing,
    Evan Shrubsole,
    FranÃ§ois Beaufort,
    Jan Gora,
    Jesse Barnes,
    Joshua Bell,
    Kamila Hasanbega,
    Matt Menke,
    Moh Haghighat,
    NicolÃ¡s PeÃ±a Moreno,
    Opal Voravootivat,
    Paul Jensen,
    Peter Djeu,
    Reilly Grant,
    Ulan Degenbaev,
    Victor Miura,
    and
    Zhenyao Mo
  </p>
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>
