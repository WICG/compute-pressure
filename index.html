
<!DOCTYPE html>
<meta charset="utf-8" />
<title>Compute Pressure Level 1</title>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script class="remove">
  // All config options at https://respec.org/docs/
  const respecConfig = {
    shortName: "compute-pressure",
    group: "das",
    specStatus: "ED",
    xref: "web-platform",
    github: "https://github.com/w3c/compute-pressure",
    formerEditors: [
      {
        name: "Olivier Yiptong",
        company: "Google Inc.",
        companyURL: "https://google.com",
      },
      {
        name: "Victor Costan",
        company: "Google Inc.",
        companyURL: "https://google.com",
      }
    ],
    editors: [
      {
        name: "Kenneth Rohde Christiansen",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 57705,
      },
      {
        name: "Arnaud Mandy",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 126342,
      }
    ],
    testSuiteURI: "https://github.com/web-platform-tests/wpt/labels/compute-pressure",
    xref: {
      profile: "web-platform",
      specs: [
        "permissions", "permissions-policy", "hr-time", "picture-in-picture", "mediacapture-streams"
      ]
    }
  };
</script>
<style>
  @counter-style pressure-states-emoji {
    system: cyclic;
    symbols: "âšª" "ðŸŸ¢" "ðŸŸ¡" "ðŸ”´";
    suffix: " ";
  }
  .pressure-states {
    list-style-type: pressure-states-emoji;
  }
  @counter-style pressure-factors-emoji {
    system: cyclic;
    symbols: "ðŸŒ¡" "ðŸ”Œ";
    suffix: " ";
  }
  .pressure-factors {
    list-style-type: pressure-factors-emoji;
  }
</style>
<section id="abstract">
  <p>
    The <cite>Compute Pressure API</cite> provides a way for websites to react to changes
    in the CPU pressure of the target device, such that websites can trade off
    resources for an improved user experience.
  </p>
</section>
<section id="sotd"></section>
<section class="informative">
  <h2>Introduction</h2>
  <p>
    Modern applications often need to balance the trade offs and advantages of fully utilizing
    the system's computing resources, in order to provide a modern and delightful user experience.
  </p>
  <p>
    As an example, many applications can render video effects with varying degrees of sophistication.
    These applications aim to provide the best user experience, while avoiding driving the user's
    device into a high pressure regime.
  </p>
  <p>
    Utilization of [=processing units=] close to and often reaching 100% can lead to a bad
    user experience, as different tasks are fighting for the processing time.
    This can lead to slowless, which is especially noticeable with input delay.

    Further, a prolonged utilization close 100% can cause the [=processing units=] to heat up due to prolonged
    boosting, which can lead to throttling, resulting in an even worse user experience.
  </p>
  <p>
    As a result of thermal limits, many smartphones, tablets and laptops can become uncomfortably hot
    to the touch. The fans in laptops and desktops can become so loud that they disrupt conversations
    or the usersâ€™ ability to focus.
  </p>
  <p>
    In many cases, a device under high pressure appears to be unresponsive, as the operating
    system may fail to schedule the threads advancing the task that the user is waiting for. See also
    <a href="https://github.com/wicg/compute-pressure/#goals--motivating-use-cases">Use Cases</a>.
  </p>
</section>
<section>
  <h2>A Note on Feature Detection</h2>
  <p><i>This section is non-normative.</i></p>
  <p>
    Feature detection is an established web development best practice. Resources on the topic are plentiful on- and
    offline and the purpose of this section is not to discuss it further, but rather to put it in the context of
    detecting hardware-dependent features.
  </p>
  <p>
    Consider the below feature detection examples:
  </p>
  <aside class="example" title="Checking existence of PressureObserver interface">
    <p>
      This simple example illustrates how to check whether the [=User Agent=] exposes the
      {{PressureObserver}} interface
    </p>
    <pre class="js">
      if ("PressureObserver" in globalThis) {
        // Use PressureObserver interface
      }
    </pre>
  </aside>
  <aside class="note">
    <p>
      Checking against {{globalThis/globalThis}} will work on any [=ECMAScript/agent=] as defined by
      [[ECMAScript]], thus also in workers.
    </p>
    <p>
      It does however not tell you whether that API is actually connected to a
      real [=platform collector=], whether the [=platform collector=] is collecting real telemetry
      readings, or whether the user is going to allow you to access it.
    </p>
  </aside>
</section>
<section>
  <h2>Concepts</h2>
  <p>
    This specification defines the following concepts:
  </p>
  <section>
    <h3>Processing Units</h3>
    <p>
      Computing devices consist of a multitude of different <dfn>processing units</dfn> such as the Central
      Processing Unit (CPU), the Graphics Processing Unit (GPU) and many specialized
      processing units. The latter are becoming popular such as ones designed to accelerate specific
      tasks like machine learning or computer vision.
    </p>
  </section>
  <section>
    <h3>Supported sources</h3>
    <p>
      The specification currently defines the <dfn>supported source types</dfn> as the
      Central [=Processing Unit=], also know  as the CPU, but intents to support other [=source types=]
      such as GPU (Graphical [=Processing Unit=]) in future levels of this specification.
      <aside class="note">
        <p>
          If a user calls {{PressureObserver/observe()}} with a [=source type=] not part of
          {{PressureSource}}, at the level of this specification the [=user agent=] supports,
          the method will throw a {{TypeError}}.
        </p>
        <p>
          If the [=source type=] is part of {{PressureSource}}, but not supported by the
          [=user agent=], host OS or underlying hardware, the method will instead throw
          {{NotSupportedError}}.
        </p>
        <p>
          To check what [=source types=] are supported, a user can call the static method
          {{PressureObserver/supportedSources()}}.
        </p>
      </aside>
    </p>
  </section>
  <section>
    <h3>Sampling and Reporting Rate</h3>
    <p>
      The <dfn>sampling rate</dfn> for a [=platform collector=] is defined as a rate
      at which the [=user agent=] obtains telemetry readings from the underlying platform,
      and it might differ from the pressure observers' [=requested sampling rates=].
    </p>
    <p>
      The <dfn>reporting rate</dfn> for a pressure observer is the rate at which it runs
      the [=data delivery=] steps.
    </p>
    <p>
      The [=sampling rate=] differs from the [=requested sampling rate=] when the
      [=requested sampling rate=] exceeds upper or lower sampling rate bounds
      supported or accepted by the underlying platform and [=user agent=]<sup>â€ </sup>.
    </p>
    <p>
      <sup>â€ </sup>It is recommended that the [=user agent=] limits the [=reporting rate=]
      as outlined in [[[#rate-limiting-change-notifications]]].
    </p>
    <p>
      In case the user didn't request a [=sampling rate=], the [=sampling rate=]
      is [=implementation-defined=].
    </p>
    <aside class="note">
      In case there are multiple instances of {{PressureObserver}} active with different
      [=requested sampling rates=], it is up to the [=user agent=] to set a
      [=platform collector=] level [=sampling rate=] that best fulfills these requests,
      while making sure that the [=reporting rate=] of all {{PressureObserver}}s does
      not exceed their respective [=requested sampling rates=].
    </aside>
  </section>
</section>

<section> <h2>Platform primitives</h2>
  <p>
    The [=platform collector=] refers to a platform interface, with which the [=user agent=] interacts to
    obtain the telemetry readings required by this specification.
  </p>
  <p>
    A [=platform collector=] can be defined by the underlying platform (e.g. in a native telemetry
    framework) or by the [=user agent=], if it has a direct access to hardware counters.
  </p>
  <p>
    A [=platform collector=] can support telemetry for different <dfn>source types</dfn> of computing
    devices defined by {{PressureSource}}, or there can be multiple [=platform collectors=].
  </p>
  <p>
    From the implementation perspective [=platform collector=] can be treated as a software proxy for the
    corresponding hardware counters. It is possible to have multiple [=platform collector=] simultaneously
    interacting with the same underlying hardware if the underlying platform supports it.
  </p>
  <p>
    In simple cases, a [=platform collector=] represents individual hardware counters, but if the provided
    counter readings are a product of data fusion performed in software, the [=platform collector=]
    represents the results of the data fusion process. This may happen in user space or in kernel space.
  </p>
  <p>
    As collecting telemetry data often means polling hardware counters, it is not a free operation and thus,
    it should not happen if there are no one observing the data. See [[[#life-cycle]]] for more information.
  </p>
  <p>
    A [=platform collector=] samples data at a specific rate. A [=user agent=] may modify this rate
    (if possible) for privacy reasons, or ignore and fuse certain readings.
  </p>
</section>

<section>
  <h3>
    User notifications
  </h3>
  <p>
    It is RECOMMENDED that a [=user agent=] show some form of unobtrusive
    notification that informs the user when a pressure observer is active,
    as well as provides the user with the means to block the ongoing operation,
    or simply dismiss the notification.
  </p>
</section>

<section>
  <h3>
    Policy control
  </h3>
  <p>
    The Compute Pressure API defines a [=policy-controlled feature=]
    identified by the token "compute-pressure".
    Its [=default allowlist=] is `["self"]`.
  </p>
  <aside class="note">
    <p>
      The <a>default allowlist</a> of `["self"]` allows usage in
      same-origin nested frames but prevents third-party content from using
      the feature.
    </p>
    <p>
      Third-party usage can be selectively enabled by adding
      `allow="compute-pressure"` attribute to the frame container element:
    </p>
    <pre class="example html" title=
    "Enabling compute pressure on remote content">
      &lt;iframe src="https://third-party.com" allow="compute-pressure"/&gt;&lt;/iframe&gt;
    </pre>
    <p>
      Alternatively, the Compute Pressure API can be disabled completely by
      specifying the permissions policy in a HTTP response header:
    </p>
    <pre class="example http" title="Feature Policy over HTTP">
      Permissions-Policy: {"compute-pressure": []}
    </pre>
    <p>
      See [[[PERMISSIONS-POLICY]]] for more details.
    </p>
  </aside>
</section>

<section>
  <h3>
    Internal Slot Definitions
  </h3>
  <p>
    Each [=global object=] has:
    <ul>
      <li>
        a <dfn>pressure observer task queued</dfn> (a boolean), which is initially false.
      </li>
      <li>
        a <dfn>registered observer list</dfn> per supported [=source type=], which is initially empty.
      </li>
      <li>
        a reference to an underlying <dfn>platform collector</dfn> as detailed in [[[#platform-primitives]]].
      </li>
    </ul>
    A <dfn>registered observer</dfn> consists of an <dfn>observer</dfn> (a {{PressureObserver}} object).
  </p>
  <p>
    A constructed {{PressureObserver}} object has the following internal slots:
  </p>
  <ul data-dfn-for="PressureObserver">
    <li>
      a <dfn>[[\Callback]]</dfn> of type {{PressureUpdateCallback}} set on creation.
    </li>
    <li>
      a <dfn>[[\SampleRate]]</dfn> double set on creation.
    </li>
    <li>
      a <dfn>[[\PendingObservePromises]]</dfn> [=list=] of zero or more source-promise [=tuples=], initially empty,
      where source holds a {{PressureSource}} string and promise holds a {{Promise}} object.
    </li>
    <li>
      a <dfn>[[\QueuedRecords]]</dfn> [=queue=] of zero or more {{PressureRecord}}
      objects, which is initially empty.
    </li>
    <li>
      a <dfn>[[\LastRecordMap]]</dfn> [=ordered map=], [=map/keyed=] on a {{PressureSource}},
      representing the [=source type=] to which the last record belongs.
      The [=ordered map=]'s [=map/value=] is a {{PressureRecord}}.
    </li>
  </ul>
  <p>
    The [=user agent=] additionally has a <dfn>max queued records</dfn> integer, which
    is set to an [=implementation-defined=] value, greater than 0.
    </li>
  </p>
</section>

<section> <h2>Pressure States</h2>
  <p>
    <dfn>Pressure states</dfn> represents the minimal set of useful states that allows websites
    to react to changes in compute and system pressure with minimal degration in quality or service,
    or user experience.
  </p>
  <pre class="idl">
    enum PressureState { "nominal", "fair", "serious", "critical" };
  </pre>
  <p>
    The <dfn>PressureState</dfn> enum represents the [=pressure state=] with the following states:
  </p>
  <p>
    <ul class="pressure-states">
      <li>
        <b>Nominal</b>: Current workloads are causing minimal pressure, allowing the system to run
        at a lower clock frequency to preserve power.
      </li>
      <li>
        <b>Fair</b>: The system is doing fine, everything is smooth and it can take on additional work without issues.
      </li>
      <li>
        <b>Serious</b>: There is some serious pressure on the system, but it is sustainable and the system
        is doing well, but it is getting close to its limits:
        <ul>
          <li>
            Clock speed (depending on AC or DC power) is consistently high
          </li>
          <li>
            Thermals are high but system can handle it
          </li>
        </ul>
        At this point, if you add more work the system may move into critical.
      </li>
      <li>
        <b>Critical</b>: The system is now about to reach its limits, but it hasnâ€™t reached <em>the</em> limit yet.
        Critical doesnâ€™t mean that the system is being actively throttled, but this state is not sustainable for
        the long run and might result in throttling if the workload remains the same. This signal is the last call
        for the web application to lighten its workload.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Contributing Factors</h2>
  <p>
    <dfn>Contributing factors</dfn> represents the factors contributing to the system performance and current [=pressure state=].
    In case the [=pressure state=] is nominal or fair, the {{PressureRecord}} internal slot {{PressureRecord/[[Factors]]}}
    will always be [=list/empty=].
  </p>
  <aside class="note">
    The [=user agent=] might not be able to expose the factors for all systems or for all [=pressure states=].
  </aside>
  <pre class="idl">
    enum PressureFactor { "thermal", "power-supply" };
  </pre>
  <p>
    The <dfn>PressureFactor</dfn> enum represents the [=contributing factors=]:
  </p>
  <p>
    <ul class="pressure-factors">
      <li>
        <b>Thermal</b>: The source is under elevated thermal conditions and the system is
        unable to keep temperature below safe limits at peak power.
      </li>
      <li>
        <b>Power</b>: The power supply (incl. battery capacity) is too weak to run at peak power,
        or artificially limited by a system or user initiated power mode to conserve power or
        avoid fan noise.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Pressure Observer</h2>
The Compute Pressure API enables developers to understand the pressure
of system resources such as the CPU.

<section data-dfn-for="PressureObserverCallback">
  <h3>The <a>PressureUpdateCallback</a> callback</h3>
  <pre class="idl">
    callback PressureUpdateCallback = undefined (
      sequence&lt;PressureRecord&gt; changes,
      PressureObserver observer
    );
  </pre>
  This callback will be invoked when the [=pressure state=] changes.
</section>

<section  data-dfn-for="PressureObserver"> <h2>The <a>PressureObserver</a> object</h2>
  <p>
    The {{PressureObserver}} can be used to observe changes in the [=pressure states=].
  </p>
  <pre class="idl">
    enum PressureSource { "cpu" };

    [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
    interface PressureObserver {
      constructor(PressureUpdateCallback callback, optional PressureObserverOptions options = {});

      Promise&lt;undefined&gt; observe(PressureSource source);
      undefined unobserve(PressureSource source);
      undefined disconnect();
      sequence&lt;PressureRecord&gt; takeRecords();

      [SameObject] static readonly attribute FrozenArray&lt;PressureSource&gt; supportedSources;
    };
  </pre>

  <p>The <dfn>PressureObserver</dfn> interface represents a {{PressureObserver}}.</p>

  <section>
    <h3>The <dfn>constructor()</dfn> method</h3>
    <p>
      The `new` {{PressureObserver(callback, options)}} constructor steps are:
      <ol class="algorithm">
        <li>
          Set |this|.{{PressureObserver/[[Callback]]}} to |callback:PressureUpdateCallback|.
        </li>
        <li>
          If |options|["sampleRate"] is less than or equal to 0, throw a {{RangeError}}.
        </li>
        <li>
          Set |this:PressureObserver|.{{PressureObserver/[[SampleRate]]}} to |options|["sampleRate"].
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>observe()</dfn> method</h3>
    <p>
      The {{PressureObserver/observe(source)}} method steps are:
      <ol class="algorithm">
        <li>
          Let |document:Document| be [=this=]'s [=relevant settings
          object=]'s [=associated Document=].
        </li>
        <li>
          If |document| is not null and is not [=allowed to use=] the [=policy-controlled
          feature=] token "compute-pressure", return [=a promise rejected with=] {{NotAllowedError}}.
        </li>
        <aside class="issue">
          <a href="https://github.com/wicg/compute-pressure/issues/110">
            Permission policy doesn't support workers yet #110
          </a>
        </aside>
        <li>
          Let |promise:Promise| be [=a new promise=].
        </li>
        <li>
          Let |pendingPromiseTuple| be (|source|, |promise|).
        </li>
        <li>
          [=list/Append=] |pendingPromiseTuple| to [=this=].{{PressureObserver/[[PendingObservePromises]]}}.
        </li>
        <li>
          [=promise/React=] to |promise|:
          <ul>
            If |promise| was [=resolved|fulfilled=] or [=rejected=], then:
              <ol>
                [=list/Remove=] |tuple| from [=this=].{{PressureObserver/[[PendingObservePromises]]}}.
              </ol>
          </ul>
        </li>
        <li>
          Run the following steps [=in parallel=]:
          <ol>
            <li>
              If |source:PressureSource| is not a [=supported source type=],
              [=queue a global task=] on the [=PressureObserver task source=]
              given |document|'s [=relevant global object=] |relevantGlobal|
              to reject |promise| {{NotSupportedError}} and abort these steps.
            </li>
            <li>
              Activate [=data delivery=] of |source| data to |relevantGlobal|.
            </li>
            <li>
              [=Queue a global task=] on the [=PressureObserver task source=] given |document|'s
              [=relevant global object=] |relevantGlobal| to run these steps:
              <ol>
                <li>
                  If |promise| was rejected, run the following substeps:
                  <ol>
                    <li>
                      If |relevantGlobal|'s [=registered observer list=] for |source| is [=list/empty=],
                      deactivate [=data delivery=] of |source| data to |relevantGlobal|.
                    </li>
                    <li>
                      Return.
                    </li>
                  </ol>
                </li>
                <li>
                  [=list/Append=] a new [=registered observer=] whose [=observer=] is [=this=]
                  to |relevantGlobal|'s [=registered observer list=] for |source|.
                </li>
                <li>
                  Resolve |promise|.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          Return |promise|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>unobserve()</dfn> method</h3>
    <p>
      The {{PressureObserver/unobserve(source)}} method steps are:
      <ol class="algorithm">
        <li>
          If |source:PressureSource| is not a [=supported source type=], throw {{"NotSupportedError"}}.
        </li>
        <li>
          [=list/Remove=] from |this|.{{PressureObserver/[[QueuedRecords]]}} all
          |records| associated with |source|.
        </li>
        <li>
          [=map/Remove=] |this|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          [=list/For each=] (|promiseSource|, |pendingPromise|) of [=this=].{{PressureObserver/[[PendingObservePromises]]}},
          if |source| is equal to |promiseSource|, [=reject=] |pendingPromise| with an {{AbortError}}.
        </li>
        <li>
          Let |relevantGlobal| be [=this=]'s [=relevant global object=].
        </li>
        <li>
          Remove any [=registered observer=] from |relevantGlobal|'s [=registered observer list=] for
          |source| for which [=this=] is the [=registered observer=].
        </li>
        <li>
          If the above [=registered observer list=] is [=list/empty=],
          deactivate [=data delivery=] of |source| data to |relevantGlobal|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>disconnect()</dfn> method</h3>
    <p>
      The {{PressureObserver/disconnect()}} method steps are:
      <ol class="algorithm">
        <li>
          [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=map/Clear=] |this|.{{PressureObserver/[[LastRecordMap]]}}.
        </li>
        <li>
          [=list/For each=] (|promiseSource|, |pendingPromise|) of [=this=].{{PressureObserver/[[PendingObservePromises]]}},
          [=reject=] |pendingPromise| with an {{AbortError}}.
        </li>
        <li>
          Let |relevantGlobal| be [=this=]'s [=relevant global object=].
        </li>
        <li>
          Remove any [=registered observer=] from |relevantGlobal|'s' [=registered observer list=] for
          all supported [=source types=] for which [=this=] is the [=observer=].
        </li>
        <li>
          If the above [=registered observer list=] is [=list/empty=],
          deactivate [=data delivery=] of |source| data to |relevantGlobal|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>takeRecords()</dfn> method</h3>
    <aside class="note">
      <p>
        A common use case for this is to immediately fetch all pending state change records
        immediately prior to disconnecting the observer, so that any pending state changes
        can be processed when shutting down the observer.
      </p>
      <p>
        Another use case is the ability to receive any pending, already-generated states
        changes without waiting for the callbacks to be invoked. Callbacks are invoked from
        a task queue as part of the event loop cycle, so this allows for conferring the
        current state outside of the event loop cycle.
      </p>
    </aside>
    <p>
      The {{PressureObserver/takeRecords()}} method steps are:
      <ol class="algorithm">
        <li>
          Let |records| be a [=list/clone=] of |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          Return |records|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>supportedSources</dfn> attribute</h3>
    <p>
      The {{PressureObserver/supportedSources}} attribute is informing on the [=supported source type=] by the [=platform collector=].
    </p>
    <p>
      The {{PressureObserver/supportedSources}} getter steps are:
      <ol class="algorithm">
        <li>
          Let |sources| be a [=list=] of |source:PressureSource|.
        </li>
        <li>
          Return |observer|'s frozen array of supported [=source types=].
        </li>
      </ol>
    </p>
    <aside class="note">
      <p>
        This attribute allows web developers to easily know which [=source types=] are supported by the user agent.
      </p>
    </aside>
  </section>
</section>

<section data-dfn-for="PressureRecord">
  <h3>The <dfn>PressureRecord</dfn> interface</h3>
  <pre class="idl">
    [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
    interface PressureRecord {
      readonly attribute PressureSource source;
      readonly attribute PressureState state;
      readonly attribute FrozenArray&lt;PressureFactor&gt; factors;
      readonly attribute DOMHighResTimeStamp time;
    };
  </pre>
  <p>
    A constructed  {{PressureRecord}} object has the following internal slots:
  </p>
  <ul data-dfn-for="PressureRecord">
    <li>
      a <dfn>[[\Source]]</dfn> value of type {{PressureSource}}, which represents the current [=source type=].
    </li>
    <li>
      a <dfn>[[\State]]</dfn> value of type {{PressureState}}, which represents the current [=pressure state=].
    </li>
    <li>
      a <dfn>[[\Factors]]</dfn>, which is [=ordered set=] of {{PressureFactor}} values,
      which represents the current [=contributing factors=].
    </li>
    <li>
      a <dfn>[[\Time]]</dfn> value of type {{DOMHighResTimeStamp}},
      which corresponds to the
      time the data was obtained from the system, relative to the [=time origin=] of the global object associated with
      the {{PressureObserver}} instance that generated the notification.
    </li>
  </ul>
  <section>
    <h3>The <dfn>source</dfn> attribute</h3>
    <p>
      The {{PressureRecord/source}} [=getter steps=] are to return its {{PressureRecord/[[Source]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>state</dfn> attribute</h3>
    <p>
      The {{PressureRecord/state}} [=getter steps=] are to return its {{PressureRecord/[[State]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>factors</dfn>  attribute</h3>
    <p>
      The {{PressureRecord/factors}} [=getter steps=] are to return its {{PressureRecord/[[Factors]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>time</dfn> attribute</h3>
    <p>
      The {{PressureRecord/time}} [=getter steps=] are to return its {{PressureRecord/[[Time]]}} internal slot.
    </p>
  </section>
</section>

<section data-dfn-for="PressureObserverOptions">
  <h3>The <dfn>PressureObserverOptions</dfn> dictionary</h3>
  <pre class="idl">
    dictionary PressureObserverOptions {
      double sampleRate = 1.0;
    };
  </pre>
  <section>
    <h3>The <dfn>sampleRate</dfn> member</h3>
    <p>
      The {{PressureObserverOptions/sampleRate}} member represents the <dfn>requested sampling
      rate</dfn> expressed in Hz, ie. it represents the number of samples requested to be obtained
      from the hardware per second. The [=reporting rate=] will never exceed the [=requested sampling rate=].
    </p>
    <aside class="note">
      <p>
        For slow sampling rates (less than 1hz), it is common to use seconds and talk about
        period instead of rate. Fortunately, it is easy to convert between the two, as hertz
        is rotations per second. If you want to request a sampling rate of 10 seconds, then
        just use the value of 0.1.
      </p>
      <p>
        A [=user agent=] might not be able to respect the requested sampling rate. For more information
        consult [[[#sampling-and-reporting-rate]]].
      </p>
    </aside>
  </section>
</section>

<section id="life-cycle">
  <h3>Life-cycle and garbage collection</h3>
  <p>
    Each [=global object=] has a
    strong reference to [=registered observers=] in their [=registered observer list=]
    (one per source).
  </p>
  <aside class="note">
    <p>
      A {{PressureObserver}} is observing a |source:PressureSource| if it
      exists in the [=registered observer list=], modified by invocations of
      {{PressureObserver/observe()}},
      {{PressureObserver/unobserve()}}
      and {{PressureObserver/disconnect()}}.
    </p>
    <p>
      This means that a {{PressureObserver}} object |observer:PressureObserver| will
      remain alive (thus not be garbage collection) until both of these conditions hold:
      <ul>
        <li>
          There are no scripting references to the |observer|.
        </li>
        <li>
          The |observer| is not observing any |source|.
        </li>
      </ul>
    </p>
    <p>
      [[[#cb-observer-example]]] contains an example of how to use the
      {{PressureObserver/disconnect()}} (or any other {{PressureObserver}}
      method) from the observer callback.
    </p>
  </aside>
</section>

<section id="processing-model">
  <h3>Processing Model</h3>
  <p>
    This section outlines the steps the user agent must take when implementing the specification.
  </p>
  <section>
    <h3>Supporting algorithms</h3>
    <p>
      <aside class="note">
        Readings are available for [=documents=] (incl. [=iframes=] and popup windows) and workers,
        matching the following criteria:
        <ul>
          <li>
            They are [=Document/fully active=] [=documents=], or
            they are <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">active needed workers</a>.
          </li>
          <li>
            Their [=origin=] is [=same origin-domain=] with the [=Node/node document|document=] containing the
            <a href="https://html.spec.whatwg.org/multipage/interaction.html#focused">focused</a> [=node=], or an
            <a href="https://w3c.github.io/picture-in-picture/#initiators-of-active-picture-in-picture-sessions">
            initiator of an active Picture-in-Picture session</a>, or the browsing [=context is capturing=],
            including microphone, camera and display.
          </li>
        </ul>
      </aside>
      The <dfn>passes privacy test</dfn> steps given the argument |observer:PressureObserver|, are as follows:
      <ol>
        <li>
          Let |relevantGlobal| be |observer|'s [=relevant global object=].
        </li>
        <li>
          If |relevantGlobal| is a {{Window}} object:
          <ol>
            <li>
              If |relevantGlobal|'s [=associated document=] is not [=Document/fully active=], return false.
            </li>
          </ol>
        </li>
        <li>
          If |relevantGlobal| is a {{WorkerGlobalScope}} object:
          <ol>
            <li>
              If |relevantGlobal|'s relevant worker is not a <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
              active needed worker</a>, return false.
            </li>
          </ol>
        </li>
        <li>
          [=list/For each=] |origin| in
          <a href="https://w3c.github.io/picture-in-picture/#initiators-of-active-picture-in-picture-sessions">
            initiators of active Picture-in-Picture sessions</a>:
          <ol>
            <li>
              If |relevantGlobal|'s [=relevant settings object=]'s [=origin=] is [=same origin-domain=] with |origin|, return true.
            </li>
          </ol>
        </li>
        <li>
          If |relevantGlobal|'s [=browsing context=] is [=context is capturing|capturing=], return true.
        </li>
        <li>
          Let |topLevelBC| be |relevantGlobal|'s [=browsing context=]'s [=top-level browsing context=].
        </li>
        <li>
          If |topLevelBC| does not have [=top-level traversable/system focus=], return false.
        </li>
        <li>
          Let |focusedDocument| be the |topLevelBC|'s
          <a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">
            currently focused area</a>'s [=Node/node document=].
        </li>
        <li>
          If |relevantGlobal|'s [=relevant settings object=]'s [=origin=] is [=same origin-domain=] with
          |focusedDocument|'s [=origin=], return true.
        </li>
        <li>
          Otherwise, return false.
        </li>
      </ol>
      <aside class="note">
        As there might be multiple observers, each with a different [=requested sampling rate=], the underlying
        [=platform collector=] will need to use a [=sampling rate=] that fulfills all these requirements. This also
        means that not every data sample from the [=platform collector=] needs to be delivered to each active
        observer.
      </aside>
      The <dfn>passes rate test</dfn> steps given the argument |observer:PressureObserver|,
      |source:PressureSource| and |timestamp:DOMHighResTimeStamp|, are as follows:
      <ol>
        <li>
          If |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:PressureRecord| be |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          Let |sampleRate| be |observer|.{{PressureObserver/[[SampleRate]]}}.
        </li>
        <li>
          Let |timeDeltaMilliseconds:DOMHighResTimeStamp| = |timestamp| - |record|.{{PressureRecord/[[Time]]}}.
        </li>
        <li>
          Let |intervalSeconds| = 1 / |sampleRate|.
        </li>
        <li>
          If (|timeDeltaMilliseconds| / 1000) &ge; |intervalSeconds|, return true, otherwise return false.
        </li>
      </ol>
      The <dfn>has change in data</dfn> steps given the argument |observer:PressureObserver|, |source:PressureSource|,
      |state:PressureState| and |factors:ordered set of PressureFactor|, are as follows:
      <ol>
        <li>
          If |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:PressureRecord| be |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          If |record|.{{PressureRecord/[[State]]}} is not equal to |state|, return true.
        </li>
        <li>
          If |record|.{{PressureRecord/[[Factors]]}} and |factors| are not [=set/supersets=] of each other, return true.
        </li>
        <li>
          Return false.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Data delivery</h3>
    <p>
      [=Data delivery=] from a [=platform collector=] can be activate and deactivated in an
      [=implementation-defined=] manner per [=source type=] and [=global object=].
    </p>
    <aside class="note">
      It is recommended that the [=platform collector=] suspends low-level data polling
      when there is no active [=data delivery=] to any {{PressureObserver}} [=relevant global object=].
    </aside>
    <p>
      The <dfn>data delivery</dfn> steps that are run when
      an [=implementation-defined=] |data| sample of [=source type=] |source:PressureSource| is
      obtained from [=global object=] |relevantGlobal|'s [=platform collector=],
      are as follows:
      <ol>
        <li>
          Let |source:PressureSource| be the [=source type=] of the |data| sample.
        </li>
        <li>
          Let |state:PressureState| be an [=implementation-defined=] state given
          |data| and |source|.
        </li>
        <li>
          Let |factors:ordered set of PressureFactor| be an [=implementation-defined=]
          [=ordered set=] given |data| and |source|, potentially [=list/empty=].
        </li>
        <li>
          Let |timestamp:DOMHighResTimeStamp| be a timestamp representing the time the |data| was
          obtained from the |relevantGlobal|'s [=platform collector=].
        <aside class="note">
          The |data| sample and mapping between |data| sample, and [=pressure states=]
          and [=contributing factors=] to the current state,
          is [=implementation-defined=] and may use many different metrics. For instance,
          for CPU, it might consider processor frequency and utilization, as well
          as thermal conditions.
        </aside>
        </li>
        <li>
          [=list/For each=] |observer:PressureObserver| in |relevantGlobal|'s
          [=registered observer list=] for |source|:
          <ol>
            <li>
              If running [=passes privacy test=] with |observer|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=passes rate test=] with |observer|, |source| and |timestamp|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=has change in data=] with |observer|, |source|, |state| and |factors|
              returns false, [=iteration/continue=].
            </li>
            <li>
              Run [=queue a record=] with |observer|, |source|, |state|, |factors| and |timestamp|.
            </li>
          </ol>
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Queue a PressureRecord</h3>
    <p>
      To <dfn>queue a record</dfn> given the arguments |observer:PressureObserver|,
      |source:PressureSource|, |state:PressureState|,
      |factors:ordered set of PressureFactor| and |timestamp:DOMHighResTimeStamp|,
      run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Let |record:PressureRecord| be a new {{PressureRecord}} object with its
        {{PressureRecord/[[Source]]}} set to |source|,
        {{PressureRecord/[[State]]}} set to |state|,
        {{PressureRecord/[[Factors]]}} set to  |factors|
        and {{PressureRecord/[[Time]]}} set to |timestamp|.
      </li>
      <li>
        If [=list/size=] of |observer|.{{PressureObserver/[[QueuedRecords]]}} is greater than
        [=max queued records=], then [=list/remove=] the first [=list/item=].
      <li>
        [=list/Append=] |record| to |observer|.{{PressureObserver/[[QueuedRecords]]}}.
      </li>
      <li>
        Set |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] to |record|.
      </li>
      <li>
        [=Queue a pressure observer task=] with |observer|'s [=relevant global object=].
      </li>
    </ol>
  </section>
  <section>
    <h3>Queue a Pressure Observer Task</h3>
    <p>
      The <dfn>PressureObserver task source</dfn> is a [=task source=] used for scheduling tasks to [[[#notify-observers]]].
    </p>
    <p>
      To <dfn>queue a pressure observer task</dfn> given |relevantGlobal| as input, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        If the |relevantGlobal|'s [=pressure observer task queued=] is true, then return.
      </li>
      <li>
        Set the |relevantGlobal|'s [=pressure observer task queued=] to true.
      </li>
      <li>
        [=Queue a global task=] on [=PressureObserver task source=] with |relevantGlobal| to [=notify pressure observers=].
      </li>
    </ol>
  </section>
  <section id="notify-observers">
    <h3>Notify Pressure Observers</h3>
    <p>
      To <dfn>notify pressure observers</dfn> given |relevantGlobal| as input, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Set |relevantGlobal|'s [=pressure observer task queued=] to false.
      </li>
      <li>
        Let |notifySet| be a new [=set=] of all [=observers=] in
        |relevantGlobal|â€™s [=registered observer lists=].
      </li>
      <li>
        [=list/For each=] |observer:PressureObserver| of |notifySet|:
        <ol>
          <li>
            Let |records| be a [=list/clone=] of |observer|.{{PressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            If |records| is not [=list/empty=], then invoke |observer|.{{PressureObserver/[[Callback]]}}
            with |records| and |observer|. If this throws an exception, catch it, and [=report the exception=].
          </li>
        </ol>
      </li>
    </ol>
  </section>
  <section>
    <h3>Handling change of fully active</h3>
    <p>
      When a {{Document}} |document| is no longer [=Document/fully active=],
      deactivate [=data delivery=] of data of all [=supported source types=] to |document|'s [=relevant global object=].
    </p>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal| is no longer
      an <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>,
      deactivate [=data delivery=] of data of all [=supported source types=] to |relevantGlobal|.
    </p>
    <p>
      When a {{Document}} |document| becomes [=Document/fully active=],
      for each non-[=list/empty=] [=registered observer list=] associated the [=source type=] |source|,
      activate [=data delivery=] of |source| data to |document|'s [=relevant global object=].
    </p>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal| becomes
      an <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>,
      for each non-[=list/empty=] [=registered observer list=] associated the [=source type=] |source|,
      activate [=data delivery=] of |source| data to |document|'s [=relevant global object=].
    </p>
    <aside class="note">
      When a document is no longer [=Document/fully active=] (or associated workers no longer
      <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>), like when
      entering the back/forward cache, or "BFCache" for short, then no events are send to the pressure observers
      (see [=passes privacy test=])
      in accordance with <a href="https://www.w3.org/TR/design-principles/#listen-fully-active">
      Web Platform Design Principles: Listen for changes to fully active status</a>. This means that the
      system can safely deactivate [=data delivery=] from the associated [=platform collector=],
      but also that it needs to be re-activated when the opposite happens.
    </aside>
  </section>

  <section id="unload-observers">
    <h3>Handle unloading document and closing of workers</h3>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal|,
      once |relevantGlobal|'s [=WorkerGlobalScope/closing=] flag is set to true,
      deactivate [=data delivery=] for all [=supported source types=] to |relevantGlobal|.
    </p>
    <p>
      As one of the [=unloading document cleanup steps=] given {{Document}} |document|,
      deactivate [=data delivery=] for all [=supported source types=] to |document|'s [=relevant global object=].
    </p>
  </section>
</section>

<section>
  <h2>
    Security and privacy considerations
  </h2>
  <p>
    Please consult the <a href="security-privacy-self-assessment.md">Security and Privacy Self-Assessment</a>
    based upon the [[[security-privacy-questionnaire]]].
  </p>
  <section>
    <h3>Minimizing information exposure</h3>
    <p>
      Exposing hardware related events related to low -level details such as exact CPU
      utilization or frequency
      <a href="https://w3ctag.github.io/design-principles/#device-ids">
      increases the risk of harming the user's privacy</a>.
    </p>
    <p>
      To mitigate this risk, no such low level details are exposed.
    </p>
    <p>
      The subsections below describe the processing model. At a high level, the
      information exposed is reduced by the following steps:
      <ol>
        <li>
          <b>Rate-limiting</b> - The user agent notifies the application of changes in
          the information it can learn. Change notifications are rate-limited.
        </li>
        <li>
          <b>first-party context</b> - The feature is only available in first-party
          contexts.
        </li>
      </ol>
      <section>
        <h4>Rate-limiting change notifications</h4>
        <p>
          We propose exposing the pressure state via
          rate-limited change notifications. This aims to remove the ability to observe
          the precise time when a value transitions between two states.
        </p>
        <p>
          More precisely, once the pressure observer is activated, it will be
          called once with initial values, and then be called when the values change.
          The subsequent calls will be rate-limited. When the callback is
          called, the most recent value is reported.
        </p>
        <p>
          The specification will recommend a rate limit of at most one call per second
          for the active window, and one call per 10 seconds for all other windows. We
          will also recommend that the call timings are jittered across origins.
        </p>
        <p>
          These measures benefit the user's privacy, by reducing the risk of
          identifying a device across multiple origins. The rate-limiting also benefits
          the user's security, by making it difficult to use this API for timing attacks.
          Last, rate-limiting change callbacks places an upper bound on the performance
          overhead of this API.
        </p>
        <p>
          Rate limiting can be implemented in the user agent, but it might also be
          possible to simply change the polling/sampling rate of the underlying hardware
          counters, if not accessed via a higher level framework.
        </p>
      </section>
      <section>
        <h4>No side-channels</h4>
        <p>
          It is possible to identify users across non-[=same origin=] sites if unique
          or very precise values can be accessed at the same time by sites not sharing
          origin.
        </p>
        <p>
          If the same [=pressure state=] and timestamp is observed by two origins, that
          would be a good indication that the origin is used by the same user on the
          same machine. For this reason, the API limits reporting [=pressure
          state=] changes to one origin at the time.
        </p>
        <p>
          A common way to do this, is only to report changes to the focused page, but
          one of the main users of this API are video conferencing sites. These sites
          want to make sure that the video streams and effects doesn't negatively affect
          the system and thus the conferencing experience - but there are two common
          cases where the site will usually not be focused:
          <ul>
            <li>
              The user is taking meeting notes and the site is in the background. Commonly
              the video stream is only visible via a picture-in-picture window.
            </li>
            <li>
              The user is sharing an external application window such as a presentation,
              or sharing the whole screen, unusually with some UI indicating sharing is
              happening.
            </li>
          </ul>
          For this reason, the API considers these two cases to have
          higher priority than whether the site is focused.
        </p>
      </section>
      <section>
        <h4>First-party contexts</h4>
        <p>
          This API will only be available in frames served from the same origin as the
          top-level frame. This requirement is necessary for preserving the privacy
          benefits of the API's quantizing scheme.
        </p>
        <p>
          The same-origin requirement above implies that the API is only available in
          first-party contexts.
        </p>
      </section>
    </p>
  </section>
</section>
<section id="examples" class="informative">
  <h2>
    Examples
  </h2>
  <pre class="example js" title="How to access observer from callback" id="cb-observer-example">
    const samples = [];

    function pressureChange(records, observer) {
      for (const record of records) {
        samples.push(record.state);

        // We only want 20 samples.
        if (samples.length == 20) {
          observer.disconnect();
          return;
        }
      }
    }

    const observer = new PressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example we want to lower the number of concurrent video streams when the
    pressure becomes critical. For the sake of simplicity we only consider this one state.
  </p>
  <p>
    As lowering the amount of streams might not result in exiting the critical state,
    or at least not immediately, we use a strategy where we lower one stream at the time
    every 30 seconds while still in the critical state.
  </p>
  <p>
    We accomplish this by making sure the callback is called at least once every 30 seconds,
    or when the state actually changes. When the state changes we reset the interval timer.
  </p>
  <pre class="example js" title="How to adjust the number of video feeds based on CPU pressure">
    let timerId = -1;
    function pressureChange(records) {
      // Clear timer every time we are called, either by an actual state change,
      // or when called by setTimeout (see below).
      if (timerId > 0) {
        clearTimeout(timerId);
      }

      // When entering critical state, we want to recheck every 30sec if we are
      // still in critical state and if so, further reduce our concurrent streams.
      // For this reason we create a timer for 30 seconds that will call us back
      // with the last result in there were no change.
      const lastRecordArray = [records.at(records.length - 1)];
      timerId = setTimeout(pressureChange.bind(this, lastRecordArray), 30_000);

      for (const record of records) {
        if (record.state == "critical") {
          let streamsCount = getStreamsCount();
          setStreamsCount(streamsCount--);
        }
      }
    }

    const observer = new PressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{PressureObserver/takeRecords()}},
    by retrieving the remaining |records| accumulated since the the callback was last
    invoked.
  </p>
  <p>
    It is recommended to do so before {{PressureObserver/disconnect()}},
    otherwise {{PressureObserver/disconnect()}} will clear them and they will be lost forever.
  </p>
  <p>
    For example, we might want to measure the pressure during a benchmarking workload, and thus
    want pressure telemetry for the exact duration of the workload. This means disconnecting all
    observers immediately when the task is completed, and manually requesting any pending pressure
    telemetry up to this point that might not have been delivered yet as part of the event loop cycle.
  </p>
  <pre class="example js" title="How to handle all state changes right up until disconnect">
    function logWorkloadStatistics(records) {
      // do something with records.
    }

    const observer = new PressureObserver(logWorkloadStatistics);
    observer.observe("cpu");

    // Read pending state change records, otherwise they will be cleared
    // when we disconnect.
    const records = observer.takeRecords();
    logWorkloadStatistics(records);

    observer.disconnect();
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching a specific
    |source:PressureSource| by invoking {{PressureObserver/unobserve()}}
    with |source|.
  </p>
  <aside class="note">
    The example uses 'gpu', which could be a potential future addition to the specification. It aims to show
    that the API is extentable to support other types of pressure in the future
  </aside>
  <pre class="example js" title="How to tell the observer to stop watching for state changes for a specific source">
    const observer = new PressureObserver(records => { // do something with records. }));

    observer.observe("cpu");
    observer.observe("gpu");

    // Callback now gets called whenever the pressure state changes for 'cpu' or 'gpu'.

    observer.unobserve("gpu");

    // Callback now only gets called whenever the pressure state changes for 'cpu'.
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching for any
    state changes by calling {{PressureObserver/disconnect()}}. Calling
    {{PressureObserver/disconnect()}} will stop observing all sources observed
    by previous {{PressureObserver/observe()}} calls.
  </p>
  <p>
    Additionally it will clear all pending records collected since the last callback was invoked.
  </p>
  <pre class="example js" title="how to tell the observer to stop watching for any state changes">
    const observer = new PressureObserver(records => { // do something with records. });
    observer.observe("cpu");
    observer.observe("gpu");

    // some time later...

    observer.disconnect();

    // records will be an empty array, because of the previous disconnect().
    const records = observer.takeRecords();
  </pre>
</section>
<section id="conformance">
  <p>
    This specification defines conformance criteria for a single product: a
    <dfn>user agent</dfn> that implements the interfaces that it contains.
  </p>
</section>
<section class="appendix informative" id="acknowledgments"> <h2>Acknowledgments</h2>
  <p>
    Many thanks for valuable feedback and advice from
    Anssi Kostiainen,
    Asaf Yaffe,
    Chen Xing,
    Evan Shrubsole,
    FranÃ§ois Beaufort,
    Jan Gora,
    Jesse Barnes,
    Joshua Bell,
    Kamila Hasanbega,
    Matt Menke,
    Moh Haghighat,
    NicolÃ¡s PeÃ±a Moreno,
    Opal Voravootivat,
    Paul Jensen,
    Peter Djeu,
    Raphael Kubo da Costa,
    Reilly Grant,
    Ulan Degenbaev,
    Victor Miura,
    Wei Wang,
    and
    Zhenyao Mo
  </p>
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>
